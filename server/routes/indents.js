import express from 'express';
import { authenticateToken, requireRole } from '../middleware/auth.js';

const router = express.Router();

// Get all indents with enhanced stats
router.get('/', authenticateToken, async (req, res) => {
  try {
    const { status, meal, date } = req.query;
    
    const where = {};
    if (status) where.status = status;
    if (meal) where.meal = meal;
    if (date) {
      where.requestedForDate = {
        gte: new Date(date),
        lt: new Date(new Date(date).getTime() + 24 * 60 * 60 * 1000)
      };
    }

    const indents = await req.prisma.indent.findMany({
      where,
      include: {
        requester: {
          select: { name: true }
        },
        items: {
          include: {
            item: {
              select: { name: true, unit: true }
            }
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    res.json(indents);
  } catch (error) {
    console.error('Get indents error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get indent statistics for dashboard
router.get('/stats', authenticateToken, async (req, res) => {
  try {
    const currentMonth = new Date();
    currentMonth.setDate(1);
    currentMonth.setHours(0, 0, 0, 0);

    const [totalIndents, approvedIndents, issuedIndents, pendingIndents] = await Promise.all([
      req.prisma.indent.count({
        where: { createdAt: { gte: currentMonth } }
      }),
      req.prisma.indent.count({
        where: { 
          createdAt: { gte: currentMonth },
          status: 'APPROVED'
        }
      }),
      req.prisma.indent.count({
        where: { 
          createdAt: { gte: currentMonth },
          status: 'SENT'
        }
      }),
      req.prisma.indent.count({
        where: { status: 'PENDING' }
      })
    ]);

    res.json({
      totalIndents,
      approvedIndents,
      issuedIndents,
      pendingIndents
    });
  } catch (error) {
    console.error('Get indent stats error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get single indent
router.get('/:id', authenticateToken, async (req, res) => {
  try {
    const indent = await req.prisma.indent.findUnique({
      where: { id: req.params.id },
      include: {
        requester: {
          select: { name: true }
        },
        items: {
          include: {
            item: {
              select: { id: true, name: true, unit: true }
            }
          }
        }
      }
    });

    if (!indent) {
      return res.status(404).json({ error: 'Indent not found' });
    }

    res.json(indent);
  } catch (error) {
    console.error('Get indent error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Create new indent - Enhanced to support all meals of a day
router.post('/', authenticateToken, requireRole(['COOK', 'CHEF']), async (req, res) => {
  try {
    const { requestedForDate, meals, items, notes, autoGenerated = false } = req.body;

    // If meals array is provided, create indent for all meals
    const mealsToProcess = meals || ['LUNCH']; // Default to LUNCH if not specified

    const createdIndents = [];

    for (const meal of mealsToProcess) {
      // Calculate total estimated cost for this meal
      let totalCost = 0;
      for (const item of items) {
        const itemData = await req.prisma.item.findUnique({
          where: { id: item.itemId }
        });
        if (itemData) {
          totalCost += parseFloat(item.requestedQty) * parseFloat(itemData.costPerUnit);
        }
      }

      const indent = await req.prisma.indent.create({
        data: {
          requestedBy: req.user.id,
          requestedForDate: new Date(requestedForDate),
          meal,
          notes: `${notes || ''} - ${meal}`,
          autoGenerated,
          totalCost: totalCost.toFixed(2),
          items: {
            create: items.map(item => ({
              itemId: item.itemId,
              requestedQty: item.requestedQty.toString(),
              estimatedCost: (parseFloat(item.requestedQty) * parseFloat(item.unitCost || '0')).toFixed(2)
            }))
          }
        },
        include: {
          requester: {
            select: { name: true }
          },
          items: {
            include: {
              item: {
                select: { name: true, unit: true }
              }
            }
          }
        }
      });

      createdIndents.push(indent);
    }

    res.status(201).json({
      message: `Created ${createdIndents.length} indents`,
      indents: createdIndents
    });
  } catch (error) {
    console.error('Create indent error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Auto-generate indent from meal plans - Enhanced for all meals
router.post('/auto-generate', authenticateToken, requireRole(['COOK', 'CHEF']), async (req, res) => {
  try {
    const { date, meals } = req.body;
    const targetDate = date ? new Date(date) : new Date(Date.now() + 24 * 60 * 60 * 1000);
    const targetMeals = meals || ['BREAKFAST', 'LUNCH', 'SNACKS', 'DINNER'];
    const dayOfWeek = targetDate.getDay() === 0 ? 6 : targetDate.getDay() - 1;

    const createdIndents = [];

    for (const targetMeal of targetMeals) {
      // Get all meal plans for the specified day and meal
      const mealPlans = await req.prisma.mealPlan.findMany({
        where: {
          day: dayOfWeek,
          meal: targetMeal
        },
        include: {
          dishes: {
            include: {
              dish: {
                include: {
                  recipes: {
                    include: {
                      item: true
                    }
                  }
                }
              }
            }
          }
        }
      });

      if (mealPlans.length === 0) continue;

      // Calculate total ingredient requirements
      const ingredientMap = new Map();
      
      for (const mealPlan of mealPlans) {
        for (const dish of mealPlan.dishes) {
          for (const recipe of dish.dish.recipes) {
            const itemId = recipe.itemId;
            const qtyPer5 = parseFloat(recipe.qtyPer5Students);
            const totalQty = (qtyPer5 * mealPlan.plannedStudents) / 5;
            
            if (ingredientMap.has(itemId)) {
              ingredientMap.set(itemId, ingredientMap.get(itemId) + totalQty);
            } else {
              ingredientMap.set(itemId, totalQty);
            }
          }
        }
      }

      if (ingredientMap.size === 0) continue;

      // Create indent items
      const indentItems = [];
      let totalCost = 0;
      
      for (const [itemId, quantity] of ingredientMap) {
        const item = await req.prisma.item.findUnique({
          where: { id: itemId }
        });
        
        if (item) {
          const estimatedCost = quantity * parseFloat(item.costPerUnit);
          totalCost += estimatedCost;
          
          indentItems.push({
            itemId,
            requestedQty: quantity.toFixed(2),
            estimatedCost: estimatedCost.toFixed(2)
          });
        }
      }

      // Create the auto-generated indent
      const indent = await req.prisma.indent.create({
        data: {
          requestedBy: req.user.id,
          requestedForDate: targetDate,
          meal: targetMeal,
          notes: `Auto-generated indent for ${targetMeal} on ${targetDate.toDateString()}`,
          autoGenerated: true,
          totalCost: totalCost.toFixed(2),
          items: {
            create: indentItems
          }
        },
        include: {
          requester: {
            select: { name: true }
          },
          items: {
            include: {
              item: {
                select: { name: true, unit: true }
              }
            }
          }
        }
      });

      createdIndents.push(indent);
    }

    res.status(201).json({
      indents: createdIndents,
      itemCount: createdIndents.reduce((sum, indent) => sum + indent.items.length, 0),
      totalCost: createdIndents.reduce((sum, indent) => sum + parseFloat(indent.totalCost), 0).toFixed(2)
    });
  } catch (error) {
    console.error('Auto-generate indent error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Approve indent
router.post('/:id/approve', authenticateToken, requireRole(['CHEF', 'ADMIN']), async (req, res) => {
  try {
    const { items } = req.body;

    const indent = await req.prisma.indent.update({
      where: { id: req.params.id },
      data: {
        status: 'APPROVED',
        items: {
          updateMany: items.map(item => ({
            where: { 
              indentId: req.params.id,
              itemId: item.itemId 
            },
            data: { approvedQty: item.approvedQty }
          }))
        }
      },
      include: {
        requester: {
          select: { name: true }
        },
        items: {
          include: {
            item: {
              select: { name: true, unit: true }
            }
          }
        }
      }
    });

    res.json(indent);
  } catch (error) {
    console.error('Approve indent error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Reject indent
router.post('/:id/reject', authenticateToken, requireRole(['CHEF', 'ADMIN']), async (req, res) => {
  try {
    const { reason } = req.body;

    const indent = await req.prisma.indent.update({
      where: { id: req.params.id },
      data: {
        status: 'REJECTED',
        notes: reason
      },
      include: {
        requester: {
          select: { name: true }
        },
        items: {
          include: {
            item: {
              select: { name: true, unit: true }
            }
          }
        }
      }
    });

    res.json(indent);
  } catch (error) {
    console.error('Reject indent error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Issue items from approved indent (Store Manager)
router.post('/:id/issue', authenticateToken, requireRole(['STORE']), async (req, res) => {
  try {
    const { items } = req.body; // items: [{ itemId, batchId, qty }]

    const issue = await req.prisma.issue.create({
      data: {
        indentId: req.params.id,
        issuedBy: req.user.id,
        items: {
          create: items.map(item => ({
            itemId: item.itemId,
            batchId: item.batchId,
            qty: item.qty
          }))
        }
      }
    });

    // Update stock and ledger using FIFO
    for (const item of items) {
      // Reduce batch quantity
      await req.prisma.itemBatch.update({
        where: { id: item.batchId },
        data: {
          qtyOnHand: {
            decrement: item.qty
          }
        }
      });

      // Create stock ledger entry
      await req.prisma.stockLedger.create({
        data: {
          itemId: item.itemId,
          batchId: item.batchId,
          txnType: 'ISSUE',
          qty: -item.qty,
          refType: 'ISSUE',
          refId: issue.id,
          createdBy: req.user.id
        }
      });

      // Update indent item issued qty
      await req.prisma.indentItem.updateMany({
        where: {
          indentId: req.params.id,
          itemId: item.itemId
        },
        data: {
          issuedQty: {
            increment: item.qty
          }
        }
      });
    }

    // Update indent status to SENT
    await req.prisma.indent.update({
      where: { id: req.params.id },
      data: { status: 'SENT' }
    });

    const fullIssue = await req.prisma.issue.findUnique({
      where: { id: issue.id },
      include: {
        indent: {
          include: {
            requester: {
              select: { name: true }
            }
          }
        },
        issuer: {
          select: { name: true }
        },
        items: {
          include: {
            item: {
              select: { name: true, unit: true }
            },
            batch: {
              select: { batchNo: true }
            }
          }
        }
      }
    });

    res.status(201).json(fullIssue);
  } catch (error) {
    console.error('Issue indent error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Mark indent as received (Chef/Cook)
router.post('/:id/mark-received', authenticateToken, requireRole(['CHEF', 'COOK']), async (req, res) => {
  try {
    const { comments } = req.body;

    const indent = await req.prisma.indent.update({
      where: { id: req.params.id },
      data: {
        status: 'COMPLETED',
        notes: `Comments: ${comments || 'No comments'}`
      },
      include: {
        requester: {
          select: { name: true }
        },
        items: {
          include: {
            item: {
              select: { name: true, unit: true }
            }
          }
        }
      }
    });

    res.json(indent);
  } catch (error) {
    console.error('Mark received error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Print indent
router.get('/:id/print', authenticateToken, async (req, res) => {
  try {
    const indent = await req.prisma.indent.findUnique({
      where: { id: req.params.id },
      include: {
        requester: {
          select: { name: true }
        },
        items: {
          include: {
            item: {
              select: { name: true, unit: true }
            }
          }
        }
      }
    });

    if (!indent) {
      return res.status(404).json({ error: 'Indent not found' });
    }

    res.json(indent);
  } catch (error) {
    console.error('Print indent error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;